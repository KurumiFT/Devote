[{"title":"Maid","type":0,"sectionRef":"#","url":"/Devote/api/Maid","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#types","content":" "},{"title":"Garbage​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#Garbage","content":"&lt;/&gt; type Garbage = Instance | table | RBXScriptConnection  Type of objects that contains in Closet Table used as Garbage should implement Destroy method -- Requires local Signal = require(Packages.Signal) local myMaid = Maid.new() local mySignal = myMaid:Add(Signal.new()) -- Signal implement Destroy method  "},{"title":"Functions​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#functions","content":" "},{"title":"__index​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#__index","content":"&lt;/&gt; Maid.__index(index: any) → ((...any) → (...any)) | Garbage? Return Maid's method if exist or object from Closet by given index (could be nil)  "},{"title":"__newindex​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#__newindex","content":"&lt;/&gt; Maid.__newindex( index: any, value: Garbage? ) → () You can add items into Maid by setting value on index tip Use this for frequently used instances, for example: Signal, UI... self.myMaid = Maid.new() self.myMaid['Frame'] = Frame -- Attach Frame to Maid -- In other function if self.myMaid['Frame'] then self.myMaid['Frame'].BackgroundTransparency = 1 ... end   "},{"title":"new​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#new","content":"&lt;/&gt; Maid.new(...: Garbage?) → Maid Return new Maid object local myMaid = Maid.new()   "},{"title":"Extend​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#Extend","content":"&lt;/&gt; Maid:Extend(index: string?) → Maid Extend Maid by creating sub-maid If Sub-Maid on index is exist then return it else create new and return warning Use :Extend only using index binding (set index) Else you can create a lot of sub-maids and get performance issues due to floating objects local myMaid = Maid.new() local tweensMaid = Maid:Extend('Tweens') tweensMaid:Add(someTween) --... myMaid:Clean() -- Will clean all tweens in 'Tweens' sub-maid, but don't remove this --In other part of script local simillaryTweensMaid = Maid:Extend('Tweens') -- Here i get already exist 'Tweens' sub-maid   "},{"title":"Add​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#Add","content":"&lt;/&gt; Maid:Add(...: Garbage) → ...Garbage Push Garbage into Maid local vfxPart = Instance.new('Part') -- TODO myMaid:Add(vfxPart) note Don't forget that you can push multiple garbage in one call   "},{"title":"Destroy​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#Destroy","content":"&lt;/&gt; Maid:Destroy() → () Clean Maid from Garbage local myMaid = Maid.new() myMaid['testInstance'] = Instance.new('Part') print(myMaid['testInstance']) -- Part myMaid:Destroy() print(myMaid['testInstance']) -- nil   "},{"title":"Clean​","type":1,"pageTitle":"Maid","url":"/Devote/api/Maid#Clean","content":"&lt;/&gt; Maid:Clean() → () Allias of Maid:Destroy() local myMaid = Maid.new() myMaid['testInstance'] = Instance.new('Part') print(myMaid['testInstance']) -- Part myMaid:Clean() print(myMaid['testInstance']) -- nil  "},{"title":"Echelon","type":0,"sectionRef":"#","url":"/Devote/api/Echelon","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#functions","content":" "},{"title":"__index​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#__index","content":"&lt;/&gt; Echelon.__index(index: string) → ((...any) → (...any)) | Echelon | any Return Echelon's method if it exist or Instance's child as new Echelon or instance prop tip Use it for getting your instance property / child, don't get instance from Echelon by yourself! local VFXAsset = ... local myEon = Echelon.from(VFXAsset, true) myEon:Setup(...) -- Get Echelon's method print(myEon.Transparency) -- Get Transparency prop from instance myEon.ParticleEmitter:Setup({Rate = 50}) -- Get VFXAsset child and setup it   "},{"title":"new​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#new","content":"&lt;/&gt; Echelon.new(className: string) → Echelon Return new Echelon object from ClassName local myEon = Echelon.new('Part')   "},{"title":"from​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#from","content":"&lt;/&gt; Echelon.from( instance: Instance , shouldClone: boolean?,-- Should given instance be cloned cacheInfo: {[string]: any}?-- Private field ) → Echelon Return new Echelon object from exist Instance (wrapping) If you use asset that should be cloned, then set true in second argument local Asset = ReplicatedStorage.FireballAsset local myEon = Echelon.from(Asset, true):Setup({Parent = workspace})   "},{"title":"cache​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#cache","content":"&lt;/&gt; Echelon.cache( key: string,-- Key for cache section instance: Instance | Echelon,-- Target instance that should be cached intial_size: number?,-- Intial size of cache | Default 0 ttl: number?-- Time to live | Default nil ) → nil Assigns an Instance to a Cache Section by key When an instance is cached, it is automatically cloned Don't clone an asset when caching, this can cause undefined behavior. When caching, the object is cloned intial_size times, which avoids cloning at times when performance is needed ttl - determines when an object is removed from the cache if it is not used for a given amount of time (in seconds). 0 | nil - the object will be returned and remain in the cache until it is explicitly removed from there Echelon.cache('Fireball', Fireball_Asset, 10, 30) -- Cache fireball assets with 10 clones at once and TTL = 30 local myPart = Echelon.new('Part'):Setup({Anchored = true, Transparency = .5}) Echelon.cache('MyPart', myPart, 40) -- Cache created part with 40 clones at once without lifetime limit tip Cached object is the basis and all new objects in the current cache section will be its clones Use caching for frequently used objects, for example lasers / vfx, etc warning If you use an already existing key, the cache will be overwritten and already existing objects will be deleted   "},{"title":"Setup​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#Setup","content":"&lt;/&gt; Echelon:Setup(props: {[string]: any}) → Echelon Set properties for Echelon's instance info This method safely sets the parent only after all properties have been set. Don't use standart &quot;Instance.new('Part', workspace)&quot; Setting the parent before the set properties triggers a lot of &quot;Changed&quot; events! local myEon = Echelon.new('Part'):Setup({Name = 'MyPart', Parent = workspace})   "},{"title":"Tween​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#Tween","content":"&lt;/&gt; Echelon:Tween( tweenInfo: TweenInfo , target: {[any]: any},-- Tween's target props shouldStart: boolean?-- Should start tween immediately ) → Tween  Create tween for Echelon's instance local myEon = Echelon.from(Part) myEon:Tween(TweenInfo.new(1, Enum.EasingStyle.Sine), {Transparency = .5}, true) -- Create and start tween tip Prefer to use this instead TweenService:Create(...) cause that safely for caching instance   "},{"title":"Destroy​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#Destroy","content":"&lt;/&gt; Echelon:Destroy() → () Safely destroy Echelon with all instances local myEon = Echelon.new('Part') myEon:Destroy() -- Destroy myEon object myEon:Setup({...}) -- ERROR!   "},{"title":"Debris​","type":1,"pageTitle":"Echelon","url":"/Devote/api/Echelon#Debris","content":"&lt;/&gt; Echelon:Debris(time: number) → () Improved version of Debris:AddItem(Instance), that can working with caching local myEon = Echelon.fromCache('VFX'):Setup({CFrame = CFrame.new(0, 0, 0), Parent = workspace}) myEon:Tween(TweenInfo.new(1, Enum.EasingStyle.Sine), {Transparency = 1}, true) myEon:Debris(1)  "}]